var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"```@docs Session trainwithcockpit show_cockpit","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This page shows how to run LMD4MLTraining.jl on a small MNIST example and open a live dashboard that visualizes training dynamics in real time.\n\n","category":"section"},{"location":"getting_started/#Requirements","page":"Getting Started","title":"Requirements","text":"Julia\nA working Makie backend\n\n","category":"section"},{"location":"getting_started/#Get-the-code","page":"Getting Started","title":"Get the code","text":"Clone the repository and move into the project directory:\n\ngit clone <REPOSITORY_URL>\ncd <REPOSITORY_NAME>\n\n","category":"section"},{"location":"getting_started/#Start-Julia","page":"Getting Started","title":"Start Julia","text":"After having gotten the project open, start Julia from the project root:\n\njulia\n\n","category":"section"},{"location":"getting_started/#Activate-project-and-install-dependencies:","page":"Getting Started","title":"Activate project and install dependencies:","text":"pkg> activate .\npkg> instantiate\n\n","category":"section"},{"location":"getting_started/#Load-the-package","page":"Getting Started","title":"Load the package","text":"Exit package mode by pressing backspace and load the package:\n\njulia> using LMD4MLTraining\n\n","category":"section"},{"location":"getting_started/#Run-the-MNIST-live-monitoring-example","page":"Getting Started","title":"Run the MNIST live-monitoring example","text":"julia> include(\"examples/mnist.jl\")\n\nYou should now be able to see a window with two live plots:\n\nTraining loss versus training step \nGradient norm versus training step","category":"section"},{"location":"architecture/#Architecture","page":"Architecture","title":"Architecture","text":"This page describes the internal architecture of LMD4MLTraining.jl.\n\n","category":"section"},{"location":"architecture/#Overview","page":"Architecture","title":"Overview","text":"The package is organized into the following components:\n\nTraining backend (Flux integration)\nQuantities (metrics computed during training)\nVisualization (Makie-based dashboard)\nSession management\n\n","category":"section"},{"location":"architecture/#Module-structure","page":"Architecture","title":"Module structure","text":"cockpit/: core abstractions (session, quantities, instruments)\nvisualization/: dashboard and plotting code\nbackends/: training loop integrations\n\nThis modular design allows new quantities and visual instruments to be added without modifying the training loop logic.","category":"section"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"This page describes the visualization components of the package.\n\n","category":"section"},{"location":"visualization/#Dashboard","page":"Visualization","title":"Dashboard","text":"The dashboard displays multiple plots that update live during training.\n\nCurrently implemented plots:\n\nTraining loss vs step\nGradient norm vs step\n\n","category":"section"},{"location":"visualization/#Makie-integration","page":"Visualization","title":"Makie integration","text":"The package uses Makie.jl and observable variables to enable live updates of plots as training progresses.","category":"section"},{"location":"#LMD4MLTraining","page":"Home","title":"LMD4MLTraining","text":"Documentation for LMD4MLTraining.\n\n","category":"section"},{"location":"#LMD4MLTraining.jl","page":"Home","title":"LMD4MLTraining.jl","text":"LMD4MLTraining.jl is a Julia package for live monitoring and visual debugging of neural network training in Flux.jl.\n\nThe package is inspired by the Python package cockpit and aims to provide insight into training dynamics by visualizing diagnostic quantities while training is running.\n\n","category":"section"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"When training neural networks, issues such as unstable optimization, exploding gradients, or stalled learning are often only detected after training has finished. This package addresses this problem by providing live, interactive visualizations of important training metrics.\n\n","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Currently implemented features include:\n\nIntegration with standard Flux.jl training loops\nLive visualization using Makie.jl\nMonitoring of training loss\nMonitoring of gradient norm\nModular design for adding additional quantities and visual instruments\n\n","category":"section"},{"location":"#Project-status","page":"Home","title":"Project status","text":"This package is under active development.\n\n","category":"section"},{"location":"#Documentation-overview","page":"Home","title":"Documentation overview","text":"Getting Started: how to run the MNIST example and open the live dashboard\nArchitecture: overview of the internal design and module structure\nQuantities: description of tracked training quantities\nVisualization: dashboard and plotting design\nAPI Reference: exported types and functions","category":"section"},{"location":"#LMD4MLTraining.AbstractQuantity","page":"Home","title":"LMD4MLTraining.AbstractQuantity","text":"create a custum data type called AbstractQuantity:      - unified interface for all quantities (no changes in pipeline required        if more quantities are added later)     - compute! can be used for all quantities (depending on the specifit type        the correct logic will be later implemented)     \n\n\n\n\n\n","category":"type"},{"location":"#LMD4MLTraining.Learner","page":"Home","title":"LMD4MLTraining.Learner","text":"Learner\n\nObject bundling together all information for training with cockpit. Mutable struct so that model parameters and optimizer state  can be updated in-place during training.  Fields:     model: Any         arquitecture which parameters should be optimised during training      dataloader: Any         iterable that makes data batches accesible for training     lossfn: Function         calculate the loss of the model w.t.r to training objective (returns scalar loss value)     optim: Any         optimizer chosen to update model parameters in the backward pass (e.g. Flux.Adam)     quantities: Vector{<:AbstractQuantity}         (optional) metrics computed every training step used for evakuation and diagnostic of model training\n\n\n\n\n\n","category":"type"},{"location":"#LMD4MLTraining.Train!-Tuple{Learner, Int64, Bool}","page":"Home","title":"LMD4MLTraining.Train!","text":"Train!(learner, epochs, with_plots)\n\ntrain a Learner and render quantities (optinal).  when plotting desired: create channel to pass data from training loop to cockpit session:     - use put! to pass data into the channel (if full wait until space availiable, else add inmediately),     - use take! to returm data from the channel (if channel is empty wait until data arrives, else retrieve inmediately). \n\nArgs:     learner: Learner         contains model and model training specifications (architecture, loss function, optimizer, quantities to track, etc.)     epochs: Int         number of training epochs     withplots: Bool         user selection, if rendering is desired withplots = True\n\n\n\n\n\n","category":"method"},{"location":"#LMD4MLTraining.render_loop-Tuple{Channel, Vector{<:LMD4MLTraining.AbstractQuantity}}","page":"Home","title":"LMD4MLTraining.render_loop","text":"render_loop(channel, quantities)\n\nConsume training updates from channel and update WGLMakie plots in real time.\n\nCreates a figure using setup_plot and intialize observables data,\n\nIterates over messages from channel, expected to be (step, dict) where dict contains quantity values for that step. Appends (step, value) points to the corresponding series and updates Makie observables to trigger plot redraws  (use autolimits! to keep axes scaled to the data).\n\nThe loop terminates automatically when channel is closed and all messages have been passed.\n\nArgs:     channel: Channel:         stream of training updates (produced by training loop)     quantities: Vector{<:AbstractQuantity}         quantities defining which series to plot\n\n\n\n\n\n","category":"method"},{"location":"#LMD4MLTraining.setup_plots-Tuple{Vector{<:LMD4MLTraining.AbstractQuantity}}","page":"Home","title":"LMD4MLTraining.setup_plots","text":"setup_plots(quantities)  -> fig, observables, axs\n\nCreate a WGLMakie figure with one axis per tracked quantity.\n\nFor each quantity this function creates:\n\nan  axis at row i, column 1 of the figure grid\nan observable that holds the line data (step, value)\na line plot that updates automatically when the observable is updated\n\nThe y-axis is displayed on a log10 scale to support values spanning orders of magnitude (e.g. losses).\n\nArgs     quantities: Vector{<:AbstractQuantity}         objects defining quantities/metrics to plot\n\nReturns     fig: Figure         the Makie figure     observables: Dict{Symbol,Observable}         mapping quantity key → observable line data, update of an observable results in plot update     axs :Dict{Symbol,Axis}         mapping quantity key → axis, adjust limits while plotting\n\n\n\n\n\n","category":"method"},{"location":"#LMD4MLTraining.train_loop!-Tuple{Learner, Int64, Union{Nothing, Channel{Tuple{Int64, Dict{Symbol, Float32}}}}}","page":"Home","title":"LMD4MLTraining.train_loop!","text":"train_loop!(learner, epochs, channel)\n\nRun training for a Learner and send training quantities through a channel for visualization  Perform model optimization loop: iteration over epochs and batches, use loss and corresponding gradients w.r.t trainable  parameters to update the model in-place and compute optinal metrics (quantities). Use a global step counter for traning steps and a channel that automatically closes if task is finished or an error occurs\n\nArgs:      learner: Learner,         contains model and model training specifications (architecture, loss function, optimizer, quantities to track, etc.)     epochs: Int,         number of training epochs     channel: Channel{Tuple{Int,Dict{Symbol,Float32}}} or nothing         communication channel with capacity set to 100 to pass information between Flux backend and cockpit, needed for plotting\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Quantities","page":"Quantities","title":"Quantities","text":"Quantities are numerical values computed during training and logged for visualization.\n\n","category":"section"},{"location":"quantities/#Implemented-quantities","page":"Quantities","title":"Implemented quantities","text":"","category":"section"},{"location":"quantities/#Loss","page":"Quantities","title":"Loss","text":"The training loss measures how well the model fits the data.","category":"section"},{"location":"quantities/#Gradient-norm","page":"Quantities","title":"Gradient norm","text":"The gradient norm summarizes the magnitude of gradients across model parameters and helps detect optimization instabilities.\n\n","category":"section"},{"location":"quantities/#Planned-quantities","page":"Quantities","title":"Planned quantities","text":"Future work includes adding quantities such as curvature-related metrics and per-layer statistics, inspired by the cockpit paper.","category":"section"}]
}
